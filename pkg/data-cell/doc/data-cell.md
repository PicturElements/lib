# DataCell

`DataCell` is a generic data manager class. Its task is to streamline the loading, modification, and packaging of data. It does so through abstraction by a number of well defined public interfaces which together produce a friendly and expressive API. 

### Hooks

`DataCell` extends `@qtxr/uc/Hookable` to provide a rich set of hook tools. Hooks may be used to update state or notify different parts of the app as events unfold.

### Fetching

At the core of `DataCell` is data fetching. Data is what makes the system work, so efficient and clean data imports are vital for the system to work smoothly. When initialized, `DataCell` resolves the given configuration data into a fetcher object. This object contains all the required data to cleanly and realibly fetch data whenever needed. Fetching can be done by a number of means:

1. HTTP requests
  `DataCell` supports simple and flexible HTTP requests. Data is fetched asynchronously and fed into the system automatically. `DataCell` uses `@qtxr/request/XHRManager` under the hood to facilitate this.

2. Custom data sourcing
  The most low level way to provide data is to supply a data sourcing function manually.

All fetches are asynchronous, so calling `DataCell.prototype.fetch` will always return a Promise.

### Fetching and the Runtime

Every fetch is called with a "runtime" object. In the runtime, data can be passed for internal or external use during the fetching process. A default runtime is always generated and passed to the fetcher function. This default runtime may differ between different types of `DataCell`. The runtime can be directly edited in two ways:

1. *with*
   The cleanest way to inject data safely and cleanly is to use the .with() method. Data supplied here will directly overwrite the current runtime.

2. *processor*
   If a "runtime" processor is defined on the instance, it will be called with the current runtime. You may edit this runtime in any way you want.

### Config

DataCell employs a flexible configuration system at construction time, which also allows separate cells to be dynamically generated multiple times from the same configuration. The configuration schema is designed to be terse for clear and pretty configuration. Config may contain the following:

* method `string, default: "custom"`
  The fetch method, e.g. "get", "post" (for HTTP requests), "custom" (for custom fetching).

* fetch `function`
  The fetcher function. If you're using HTTP fetching, this field will be ignored as such requests are handled internally. If you're using custom fetching, this function is required.

* poll `object`
  Polling object. Defines continuous fetching. See below for more information.

* processors `object`
  Object containing processors. Processors are used internally to transform data as it travels through the system. Optionally, these can be added directly to the configuration object, although the identifiers of these processors must be prefixed with "$". `DataCell` uses `@qtxr/utils/process` under the hood, which means that processors may be supplied together with transformers 

* hooks `object`
  Object containing hooks. Hooks are used to cause side effects as data flows through the system.

* defer `boolean, default: true`
  Specifies if fetches should be deferred. Deferring in this case refers to queueing fetches before running them. Two major benefits with this is that multiple fetches can be queued and then resolved in a single fetch, and letting external code run to completion before fetching. The latter is particularly useful since runtime data, etc. can be processed on the fly before the fetch is being made, in which case having proper data available is crucial. In the case of many fetches being made, runtime data is modifies as follows:

  *	base runtime data is the same as generated by the last fetch
  * default runtime data remains unchanged
  * runtime data defined with .with() persists and properties are updated with very new call to .with()
  * the `runtime` processor is called right before the final fetch is made

* maxDefers `number, default: 1`
  Specifies the maximum amount of deferred fetches allowed to be running at the same time. Since a single fetch is being made, the runtime has to be shared between concurrent defers, as will the returned data. To mitigate obscure bugs arising from multiple deferred fetches, only one defer at a time is allowed by default. Trying to fetch beyond the set limit will result in a warning in the console. Any such fetch requests will still resolve to the last valid fetch.

### The Fetcher Object

The fetcher object is a major component of the system as it keeps track of everything related to the fetching and tracking of data. Fetchers follow the following structure:

	{
		method		// 
		fetch		// The fetcher function. This is what gets called when DataCell.prototype.fetch is invoked
		poll		// Polling object
		processors	// 
		hooks		// Object with hooks
	}

### The Polling Object

The polling object is used to automatically fetch new data in set intervals.

	{
		interval		// Fetching interval, in milliseconds. Defaults to 1000ms
		iterations		// Fetching count; how many times polling should be done. Defaults to Infinity
		running			// Boolean representing the running state of the polling. Defaults to true
		// The following data is set and used internally
		iterationCount
		lastTimestamp		// Timestamp at last iteration
	}

### The Watcher Object

The watcher object is used to trigger actions when the state changes. `DataCell` runs the watcher over all changes and creates a task queue. When finished, it will dispatch the tasks. Importantly, if it identifies duplicate tasks, these will be bundled together. An array of changes will be supplied to the watcher task dispatcher.

### Watcher Task Dispatchers

Watcher task dispatchers run tasks. 

### State

`DataCell` employs a state to manage how data is handled in the system.

### State transforms

Sometimes state data depends on other state data. In this case it could be useful to have abstract connections between these data. `DataCell` does this with state transforms. A state transform may be a simple function or a transform object, including a transform function. A transform function is simple. It receives a snapshot of the current state and its task is to directly mutate it, or return a new state. A transform is triggered by a new value being set in the state. The returned/mutated state will also be subject to transforms, so complex updates can be set up with ease.

Transforms are triggered relative to the current state, so if a transform runs but doesn't change a value no further transforms are triggered for that specific value.

To remain deterministic, state transforms do have some limitations. For example, a transform triggered by data A that affects data B, which in turn also transforms data A is not desirable. Therefore, transforms are only allowed to affect any one value once. If multiple transforms affect any value, an error will be logged. However, this does not apply to circular transforms. Circular transforms (A -> B -> A) will not fail, as the transforms will halt when the triggered key is found. In the event that multiple Additionally, transforms currently only apply to the root level of the state, as to reduce program complexity.
